<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hide on bush&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yqs19960816.github.io/"/>
  <updated>2018-10-12T02:33:11.755Z</updated>
  <id>http://yqs19960816.github.io/</id>
  
  <author>
    <name>Hide on bush</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS数据类型转换</title>
    <link href="http://yqs19960816.github.io/2018/08/31/Js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yqs19960816.github.io/2018/08/31/Js数据类型转换/</id>
    <published>2018-08-31T03:39:44.000Z</published>
    <updated>2018-10-12T02:33:11.755Z</updated>
    
    <content type="html"><![CDATA[<p>JS有5种简单数据类型（也称基本数据类型）：<code>undefined</code>、<code>null</code>、<code>Boolean</code>、<code>Number</code>和<code>String</code>。还有两种复杂数据类型——<code>symbol</code>（不做多介绍）和<code>Object</code>，对象本质上是由一组无序的名值对组成的，ECMAScring不支持任何创建自定义类型的机制，而所有值最终都将是上述7种数据类型之一。<br><a id="more"></a></p><h4 id="数据类型的相互转换-强制转换"><a href="#数据类型的相互转换-强制转换" class="headerlink" title="数据类型的相互转换(强制转换)"></a>数据类型的相互转换(强制转换)</h4><p>强制转换主要指使用<code>Number</code>、<code>String</code>和<code>Boolean</code>三个函数，手动将各种类型的值，分布转换成数字、字符串或者布尔值。</p><h4 id="任意数据类型转字符串"><a href="#任意数据类型转字符串" class="headerlink" title="任意数据类型转字符串"></a>任意数据类型转字符串</h4><p><code>String(x)</code>函数可以将任意类型的值转化成字符串，转换规则如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String(1)//&quot;1&quot; 数值：转为相应的字符串</span><br><span class="line"></span><br><span class="line">String(true)//&quot;true&quot; 布尔值：true转为字符串&quot;true&quot;，false转为字符串&quot;false&quot;。</span><br><span class="line"></span><br><span class="line">String(null)//&quot;null&quot; 转为字符串&quot;null&quot;。</span><br><span class="line"></span><br><span class="line">String(undefined)//&quot;undefined&quot; 转为字符串&quot;undefined&quot;。</span><br><span class="line"></span><br><span class="line">String(&#123;&#125;)//&quot;[Object Object]&quot; 对象，返回一个类型字符串；</span><br><span class="line"></span><br><span class="line">String([1, 2, 3]) // &quot;1,2,3&quot; 数组，返回该数组的字符串形式。</span><br></pre></td></tr></table></figure></p><p><code>toString()</code>方法也可以将数据转化为字符串形式，不过<code>undefined</code>和<code>null</code>没有这个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(1).toString()  //&quot;1&quot;</span><br><span class="line"></span><br><span class="line">true.toString() //&quot;true&quot;</span><br><span class="line"></span><br><span class="line">null.toString()  //Uncaught TypeError: Cannot read property &apos;toString&apos; of null</span><br><span class="line"> // at &lt;anonymous&gt;:1:6</span><br><span class="line"></span><br><span class="line">undefined.toString()  //Uncaught TypeError: Cannot read property &apos;toString&apos; of undefined</span><br><span class="line">//at &lt;anonymous&gt;:1:11</span><br><span class="line">&#123;&#125;.toString()   //Uncaught SyntaxError: Unexpected token .</span><br><span class="line"></span><br><span class="line">(&#123;&#125;).toString()  //&quot;[object Object]&quot;</span><br></pre></td></tr></table></figure></p><p><code>老司机用法：x+&#39;&#39;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1+&apos;&apos;  //  &quot;1&quot;</span><br><span class="line">true+&apos;&apos; // &apos;true&apos;</span><br><span class="line">null+&apos;&apos; // &apos;null&apos;</span><br><span class="line">undefined+&apos;&apos; // &apos;undefined&apos;</span><br><span class="line">&#123;&#125;+&apos;&apos; // 0</span><br><span class="line">var o = &#123;&#125;</span><br><span class="line">o+ &apos;&apos; //&#123;object Object&#125;</span><br></pre></td></tr></table></figure></p><h4 id="任意数据类型转数字"><a href="#任意数据类型转数字" class="headerlink" title="任意数据类型转数字"></a>任意数据类型转数字</h4><ul><li><code>Number(x)</code></li><li><code>parselnt(x，10）</code><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt" target="_blank" rel="noopener">MDN</a></li><li><code>parseFloat(x)</code><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseFloat" target="_blank" rel="noopener">MDN</a></li><li><code>x-0</code></li><li><code>+x</code></li></ul><p>原始类型值的转换规则如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 数值：转换后还是原来的值</span><br><span class="line">Number(324) // 324</span><br><span class="line"></span><br><span class="line">// 字符串：如果可以被解析为数值，则转换为相应的数值</span><br><span class="line">Number(&apos;324&apos;) // 324</span><br><span class="line"></span><br><span class="line">// 字符串：如果不可以被解析为数值，返回 NaN</span><br><span class="line">Number(&apos;324abc&apos;) // NaN</span><br><span class="line"></span><br><span class="line">// 空字符串转为0</span><br><span class="line">Number(&apos;&apos;) // 0</span><br><span class="line"></span><br><span class="line">// 布尔值：true 转成 1，false 转成 0</span><br><span class="line">Number(true) // 1</span><br><span class="line">Number(false) // 0</span><br><span class="line"></span><br><span class="line">// undefined：转成 NaN</span><br><span class="line">Number(undefined) // NaN</span><br><span class="line"></span><br><span class="line">// null：转成0</span><br><span class="line">Number(null) // 0</span><br></pre></td></tr></table></figure></p><p><code>Number</code>函数将字符串转为数值，要比<code>parseInt</code>函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为<code>NaN</code>,parseInt逐个解析字符，而Number函数整体转换字符串的类型,另外，parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。<br>对象<br>简单的规则是，Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number(&#123;a: 1&#125;) // NaN</span><br><span class="line">Number([1, 2, 3]) // NaN</span><br><span class="line">Number([5]) // 5</span><br></pre></td></tr></table></figure></p><hr><h4 id="任意数据类型转布尔值"><a href="#任意数据类型转布尔值" class="headerlink" title="任意数据类型转布尔值"></a>任意数据类型转布尔值</h4><ul><li><code>Boolean(x)</code>函数可以将任意类型的值转为布尔值.</li><li><code>!!x</code></li></ul><p>五个falsy值转换结果为false，其他的值全部为true。<br><code>0</code>         <code>NaN</code>        <code>&#39;&#39;</code>         <code>null</code>           <code>undefined</code>     </p><blockquote><p>falsy是在Boolean上下文中认定可转换为false的值。JavaScript在需要用到布尔类型的上下文中使用强制类型转换（Type  Conversion）将值转换为布尔值，比如：在条件语句或循环语句中</p></blockquote><p>注意，所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true。</p><h4 id="数据类型的相互转换-自动转换"><a href="#数据类型的相互转换-自动转换" class="headerlink" title="数据类型的相互转换(自动转换)"></a>数据类型的相互转换(自动转换)</h4><p>到以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见。<br>第一种情况，不同类型的数据互相运算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123 + &apos;abc&apos; // &quot;123abc&quot;</span><br></pre></td></tr></table></figure></p><p>第二种情况，对非布尔值类型的数据求布尔值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (&apos;abc&apos;) &#123;</span><br><span class="line">  console.log(&apos;hello&apos;)</span><br><span class="line">&#125;  // &quot;hello&quot;</span><br></pre></td></tr></table></figure></p><p>第三种情况，对非数值类型的值使用一元运算符（即+和-）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ &#123;foo: &apos;bar&apos;&#125; // NaN</span><br><span class="line">- [1, 2, 3] // NaN</span><br></pre></td></tr></table></figure></p><p>自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用String函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。</p><p>由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用Boolean、Number和String函数进行显式转换。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS有5种简单数据类型（也称基本数据类型）：&lt;code&gt;undefined&lt;/code&gt;、&lt;code&gt;null&lt;/code&gt;、&lt;code&gt;Boolean&lt;/code&gt;、&lt;code&gt;Number&lt;/code&gt;和&lt;code&gt;String&lt;/code&gt;。还有两种复杂数据类型——&lt;code&gt;symbol&lt;/code&gt;（不做多介绍）和&lt;code&gt;Object&lt;/code&gt;，对象本质上是由一组无序的名值对组成的，ECMAScring不支持任何创建自定义类型的机制，而所有值最终都将是上述7种数据类型之一。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yqs19960816.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yqs19960816.github.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://yqs19960816.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="数据类型转换" scheme="http://yqs19960816.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>原型和原型链</title>
    <link href="http://yqs19960816.github.io/2018/08/30/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yqs19960816.github.io/2018/08/30/原型和原型链/</id>
    <published>2018-08-30T04:41:35.000Z</published>
    <updated>2018-09-14T16:06:31.059Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript规定全区对象叫做global，但是浏览器把window作为全局对象（浏览器先存在的）window就是一个哈希表，有很多属性。window的属性就是全局变量。<br>window下面的属性分为两类，第一类是ECMAScript规定必须有的函数，第二类是私有的（浏览器专有，标准不一）。<br><a id="more"></a></p><h4 id="简单类型与对象的区别："><a href="#简单类型与对象的区别：" class="headerlink" title="简单类型与对象的区别："></a>简单类型与对象的区别：</h4><p><img src="https://upload-images.jianshu.io/upload_images/7762675-3a235ae4d50fae54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>简单创建的数值和通过new Number创建的数值对象区别在于内存不同,前者存放在stack中，而后者存放在heap。<br><img src="https://upload-images.jianshu.io/upload_images/7762675-3b741440d05c1dbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>将数值通过<code>Number</code>包装成对象，内存里面就有许多操作该数值的方法。但简单数据也可以调用这些办法，那为什么还需要将数值包装成对象呢？<br>答：历史原因，在发明JS时模仿JAVA声明数据（<code>new</code>关键字，满足老板需求)，第二种可以直接声明<code>var a =1</code>。 由于第二种方法无法使用<code>toString</code>等方法（只有对象才能使用方法，简单数据类型不可以），创始人使用了一个妙计（临时转换）当写<code>n.toString</code>时，隐式的声明一个temp为 <code>new Number(n)</code>，然后再调用<code>n.toString的值为temp</code>，再销毁temp数据。临时的转换，用完就销毁了。所以给简单数据类型加属性读取时将会报错，这种方法受到了开发人员的欢迎。<br><img src="https://upload-images.jianshu.io/upload_images/7762675-dbdeea3132cdb748.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="公有的属性藏在哪？"><a href="#公有的属性藏在哪？" class="headerlink" title="公有的属性藏在哪？"></a>公有的属性藏在哪？</h4><p>所有的对象都有<code>toString</code>和<code>valueOf</code>属性，那么我们是否有必要给每个对象一个<code>toString</code>和<code>valueOf</code>呢？明显不需要（内存不允许），JS的做法是把<code>toString</code>和<code>valueOf</code>放在一个对象里，暂且叫做公有属性组成的对象（原型）。</p><blockquote><p>对象分为普通对象和函数对象，<code>Object</code>和<code>Function</code>是js自带的函数对象，每个对象都有原型（null和undefined除外）可以理解为对象的默认属性和方法。</p></blockquote><h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p>通过<code>new string()</code>方法转换成的字符串对象是一个哈希，每一个字符对应相应的索引值，使用方括号或者<code>charAt(索引值)</code>来获取相对应的字符，<code>charCodeAt（索引值）</code>获取对应索引的值的编码。继承了<code>String</code>对象的方法。<br>获取一个数字对应的进制值使用<code>toString()</code>方法，如<code>（100）.toString(16)   //64</code>  可以将字符的编码转化为其他进制的编码</p><h4 id="布尔值对象"><a href="#布尔值对象" class="headerlink" title="布尔值对象"></a>布尔值对象</h4><p><img src="https://upload-images.jianshu.io/upload_images/7762675-85f479feb146a7d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>简单数据类型false和布尔对象false在被转换时是不相等的。<br><img src="https://upload-images.jianshu.io/upload_images/7762675-a8fca0101f51edf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>为什么不相等？两个对象地址值不同，自然不会相等,请牢记5个假值，对象经过布尔转换为真值。<br><img src="https://upload-images.jianshu.io/upload_images/7762675-e498313a71b73e28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>结论：所有新声明的对象都是不相等的。除非将一个对象的地址值赋值给另一个变量。</p><p><code>Number  String  Boolean   Object</code>通过以上几种方式创建的对象都具有<code>toString</code>、<code>valueof</code>方法，这两个方法哪里来的呢？如果在每个对象都定义这两个方法太占内存。实现继承的方法：原型链、</p><h4 id="要清楚原型链，首先先弄清楚对象。"><a href="#要清楚原型链，首先先弄清楚对象。" class="headerlink" title="要清楚原型链，首先先弄清楚对象。"></a>要清楚原型链，首先先弄清楚对象。</h4><p><em>普通对象,有<strong><strong>proto</strong></strong>属性(指向其原型链)，没有prototype属性。</em>原型对象,构造函数.prototype原型对象还有constructor属性指向构造函数对象<br>*函数对象，通过new Function()创建的都是函数对象。用有prototype、<strong><strong>proto</strong></strong>属性(指向原型对象)</p><h4 id="原型链概念"><a href="#原型链概念" class="headerlink" title="原型链概念"></a>原型链概念</h4><p>ECMAScript中描述了原型链的机制，将原型链作为实现继承的主要方式。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。<br>在js中，每个对象都有一个指向它的原型对象的内部链接，这个原型对象又有自己的原型，直到某个对象的原型为null为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链接结构就称为原型链。<br>JS对象有一个指向一个原型对象的链，当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象原型的原型，依此层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p><blockquote><p>所有引用类型默认都继承了<code>Object</code>，而这个继承也是通过原型链实现的，所有函数的默认原型都是<code>Object</code>的实例，因此默认原型都会包含一个内部指针，指<code>向Object.prototype</code>。这也正是所有自定义类型都会继承<code>toString（）</code>，<code>valueOf()</code>等默认方法的根本原因，所有函数的原型最顶端都有一个最终的对象原型，存储着对象本身自带方法和属性，当调用实例上的<code>toString()</code>等方法时，实际上是调用的是保存在<code>Object.prototype</code>中的那个方法。</p></blockquote><hr><p>简单回顾一下构造函数、原型和实例之间的关系：每创建一个函数都有一个prototype属性指向通过该构造函数创建实例对象的原型对象，原型对象是包含特定类型的所有实例共享的属性和方法，都包含了一个指向构造函数的指针，而实例都包含一个指向原型对象的<strong><strong>proto</strong></strong>内部指针。<br><img src="https://s1.ax1x.com/2018/09/04/iSQ05n.jpg" alt="iSQ05n.jpg"><br><img src="https://s1.ax1x.com/2018/09/04/iSQs2V.jpg" alt="iSQs2V.jpg"><br>下面是一个简单的例子：<br><img src="https://s1.ax1x.com/2018/09/04/iSQfa9.jpg" alt="iSQfa9.jpg"><br><img src="https://s1.ax1x.com/2018/09/04/iSQh5R.jpg" alt="iSQh5R.jpg"><br><img src="https://s1.ax1x.com/2018/09/04/iSQHKO.jpg" alt="iSQHKO.jpg"><br><img src="https://s1.ax1x.com/2018/09/04/iSQqqe.jpg" alt="iSQqqe.jpg"><br><a href="https://imgchr.com/i/iSQXad" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/04/iSQXad.md.jpg" alt="iSQXad.md.jpg"></a><br>两个构造函数，将其中一个构造函数的实例赋值给另一个构造函数的原型，这样另一个原型就有了指向前面那一个构造函数的原型的指针（创建的实例也会有同样的原型链），查找属性和方法会根据原型链来进行搜索，先搜索实例，再搜索原型，最后是原型的原型…..，注意此时实例的constructor指向了最开始的构造函数，而不是创建实例的函数（为了代码的严谨，可以设置为创建此实例的函数）。实现的本质是重写原型对象，代之以一个新类型的实例。原型链继承不仅会继承原型上面的属性和方法，还会继承实例上的方法和属性。</p><hr><p><img src="https://upload-images.jianshu.io/upload_images/7762675-2f71d2e8ac0de171.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o1 = new Number(1);</span><br><span class="line">var o2 =new Object(1);</span><br><span class="line">o1===o2   //false</span><br><span class="line">o1.toString()===o2.toString() //true</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>两个数值对象不相等,因为stack存放的heap地址值不同，但使用的函数是公共属性(Number的原型的属性)，因此相等。<br><img src="https://s1.ax1x.com/2018/09/03/iSQMEd.png" alt="iSQMEd.png"><br>Object()函数不加new操作符会根据传入的参数生成相应的数据类型的对象，对于Object函数来说，加不加new都是一样的效果。<br>String()函数不加new操作符是将你给定的参数变成string常量（基本类型，非对象），而加上new会生成String对象（复杂类型，字符串对象），除了Object函数以外，其他的标准库函数都是一样的效果。<br>数值的<code>toString()</code>方法和对象的<code>toString()</code>方法并不相等，因为前者可以加进制参数而且会被先搜寻到。<br><img src="https://upload-images.jianshu.io/upload_images/7762675-d884601b9af950e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>调用方法时，会经过一层一层的查找。<code>Number  String  Boolean   Object</code>都有自己的共有属性，<code>____proto____</code>都是先指向了自己的共有属性，共有属性的<code>__proto____</code>再指向了对象。<br><img src="https://upload-images.jianshu.io/upload_images/7762675-e6a4ef43167b73ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>如果对象的共有属性没有被引用的话，必将会被回收，<code>object.prototype</code>指向（引用）这个共有属性（原型）<br><img src="https://upload-images.jianshu.io/upload_images/7762675-18b79050063fef54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>当你声明一个对象时，JS引擎除了在栈内存里面存放一个hash之外，还将<code>____proto____</code>指向了你该有的共有属性（原型）。</p><h5 id="不写代码就有prototype"><a href="#不写代码就有prototype" class="headerlink" title="不写代码就有prototype"></a>不写代码就有prototype</h5><p>在没有代码的时候，<code>Number.prototype、Object.prototype、String.prototype、Boolean.prototype</code>都引用了各自的共有属性（保证不被垃圾回收机制回收），是JS定义的，不可更改的。而你的对象<code>____proto____</code>则指向了对应数据类型的<code>prototype</code>。<br><img src="https://upload-images.jianshu.io/upload_images/7762675-bcc66f9c3fee62a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>初始化数据类型里面还有一个<code>Function.prototype</code>，存储了函数的原型（共有方法），<code>Function</code>也是一个对象，<code>Function.__proto__</code>指向了<code>Function.prototype</code>，使用函数初始化对象时（<code>new Function()</code>)，该函数对象的<code>____proto____</code>就指向了<code>Function.prototype</code>（因为Function是Object的构造函数），而<code>Function.prototype</code>里面的<code>____proto____</code>就指向了<code>Object.prototype</code>。<br><img src="https://upload-images.jianshu.io/upload_images/7762675-b55a983b29328466.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>继承方式：子类构造函数.prototype= new 父类构造函数 ，简单说就是将父类的实例赋值给子类的原型，这样子类的<strong><strong>proto</strong></strong>属性<br>目前组合继承用的最多，构造函数模式定义实例属性（不可共享），原型模式则定义方法和共享的属性。</p><p>现在你明白什么是原型和原型链了吗？：）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ECMAScript规定全区对象叫做global，但是浏览器把window作为全局对象（浏览器先存在的）window就是一个哈希表，有很多属性。window的属性就是全局变量。&lt;br&gt;window下面的属性分为两类，第一类是ECMAScript规定必须有的函数，第二类是私有的（浏览器专有，标准不一）。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yqs19960816.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yqs19960816.github.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://yqs19960816.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="原型" scheme="http://yqs19960816.github.io/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="http://yqs19960816.github.io/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
      <category term="简单数据类型" scheme="http://yqs19960816.github.io/tags/%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="复杂数据类型" scheme="http://yqs19960816.github.io/tags/%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
</feed>
