<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hide on bush&#39;s Blog</title>
  
  <subtitle>心有猛虎，细嗅蔷薇。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-30T22:44:22.005Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Hide on bush</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>原型和原型链</title>
    <link href="http://yoursite.com/2018/08/30/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2018/08/30/原型和原型链/</id>
    <published>2018-08-30T04:41:35.000Z</published>
    <updated>2018-08-30T22:44:22.005Z</updated>
    
    <content type="html"><![CDATA[<h5 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h5><p>ECMAScript规定全区对象叫做global，但是浏览器把window作为全局对象（浏览器先存在的）window就是一个哈希表，有很多属性。window的属性就是全局变量。<br>window下面的属性分为两类，第一类是ECMAScript规定必须有的函数，第二类是私有的（浏览器专有，标准不一），MDN查看window下有哪些API。<br><a id="more"></a><br><img src="https://upload-images.jianshu.io/upload_images/7762675-8f7f6d355242a303.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>今天我们学习第一种全局变量。windowde的函数可以直接调用，<code>window.</code>可省略。</p><h5 id="简单类型与对象的区别："><a href="#简单类型与对象的区别：" class="headerlink" title="简单类型与对象的区别："></a>简单类型与对象的区别：</h5><p><img src="https://upload-images.jianshu.io/upload_images/7762675-3a235ae4d50fae54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>简单创建的数值和通过new Number创建的数值对象区别在于内存不同。<br><img src="https://upload-images.jianshu.io/upload_images/7762675-3b741440d05c1dbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>将数值通过<code>Number</code>包装成对象，内存里面就有许多操作该数值的方法。但简单数据也可以调用这些办法，那为什么还需要将数值包装成对象呢？<br>答：历史原因，在发明JS时模仿JAVA声明数据（<code>new</code>关键字，满足老板需求)，第二种可以直接声明<code>var a =1</code>。 由于第二种方法无法使用<code>toString</code>等方法（只有对象才能使用方法，简单数据类型不可以），创始人使用了一个妙计（临时转换）当写<code>n.toString</code>时，隐式的声明一个temp为 <code>new Number(n)</code>，然后再调用<code>n.toString的值为temp</code>，再销毁temp数据。临时的转换，用完就销毁了。所以给简单数据类型加属性读取时将会报错。<br><img src="https://upload-images.jianshu.io/upload_images/7762675-dbdeea3132cdb748.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h5 id="公有的属性藏在哪？"><a href="#公有的属性藏在哪？" class="headerlink" title="公有的属性藏在哪？"></a>公有的属性藏在哪？</h5><p>所有的对象都有<code>toString</code>和<code>valueOf</code>属性，那么我们是否有必要给每个对象一个<code>toString</code>和<code>valueOf</code>呢？明显不需要（内存不允许），JS的做法是把<code>toString</code>和<code>valueOf</code>放在一个对象里，暂且叫做公有属性组成的对象（原型）。</p><blockquote><p>对象分为普通对象和函数对象，<code>Object</code>和<code>Function</code>是js自带的函数对象，每个对象都有原型（null和undefined除外）可以理解为对象的默认属性和方法。</p></blockquote><h5 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h5><p>通过<code>new string()</code>方法转换成的字符串对象是一个哈希，每一个字符对应相应的索引值，使用方括号或者<code>charAt(索引值)</code>来获取相对应的字符，<code>charCodeAt（索引值）</code>获取对应索引的值的编码。继承了<code>String</code>对象的方法。<br>获取一个数字对应的进制值使用<code>toString()</code>方法，如<code>（100）.toString(16)   //64</code>  可以将字符的编码转化为其他进制的编码</p><h5 id="字符串常用API："><a href="#字符串常用API：" class="headerlink" title="字符串常用API："></a>字符串常用API：</h5><p>去掉两边空格<code>trim()</code><br>连接字符串 <code>concat()</code> 得到新的字符串， 和命令行cat查看命令有关，两个文件 cat 1.txt  2.txt    //将1和2的内容连接打印出来hello world<br>切片<code>slice</code>，得到两个参数之间的字符（包前不包后）<br><code>replace</code>替换，将指定的字符切换为你想要的字符，得到新的字符串、<br>基本类型也可以使用哈希表，只不过在调用的时候临时转换成了字符串对象而已</p><h5 id="布尔值对象"><a href="#布尔值对象" class="headerlink" title="布尔值对象"></a>布尔值对象</h5><p><img src="https://upload-images.jianshu.io/upload_images/7762675-85f479feb146a7d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>简单数据类型false和布尔对象false在被转换时是不相等的。<br><img src="https://upload-images.jianshu.io/upload_images/7762675-a8fca0101f51edf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>为什么不相等呢？请牢记5个假值，7个基本类型。对象是真值。<br><img src="https://upload-images.jianshu.io/upload_images/7762675-e498313a71b73e28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>两个对象地址值不同，自然不会相等。<br>结论：所有新声明的对象都是不相等的。除非将一个对象的地址值赋值给另一个变量。</p><p><code>Number  String  Boolean   Object</code>通过以上几种方式创建的对象都具有<code>toString</code>、<code>valueof</code>方法，这两个方法哪里来的呢？<br>在每个对象都定义这两个方法太占内存。解决方法：原型链、</p><h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><blockquote><p>什么是原型链：<br>ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方式。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。<br>在js中，每个对象都有一个指向它的原型对象的内部链接，这个原型对象又有自己的原型，直到某个对象的原型为null为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链接结构就称为原型链。JS对象有一个指向一个原型对象的链，当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象原型的原型，依此层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。<br>所有引用类型默认都继承了<code>Object</code>，而这个继承也是通过原型链实现的，所有函数的默认原型都是<code>Object</code>的实例，因此默认原型都会包含一个内部指针，指<code>向Object.prototype</code>。这也正是所有自定义类型都会继承<code>toString（）</code>，<code>valueOf()</code>等默认方法的根本原因，所有函数的原型最顶端都有一个最终的对象原型，存储着对象本身自带方法和属性，当调用实例上的<code>toString()</code>等方法时，实际上是调用的是保存在<code>Object.prototype</code>中的那个方法。</p></blockquote><hr><p><img src="https://upload-images.jianshu.io/upload_images/7762675-2f71d2e8ac0de171.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o1 = new Number(1);</span><br><span class="line">var o2 =new Object(1);</span><br><span class="line">o1===o2   //false</span><br><span class="line">o1.toString()===o2.toString() //true</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>两个对象不相等，但使用的属性是公共属性，因此相等。<br>数值的<code>toString()</code>方法和对象的<code>toString()</code>方法并不相等，因为前者可以加参数。<br><img src="https://upload-images.jianshu.io/upload_images/7762675-d884601b9af950e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>调用方法时，会经过一层一层的查找。<code>Number  String  Boolean   Object</code>都有自己的共有属性，<code>____proto____</code>都是先指向了自己的共有属性，共有属性的<code>__proto____</code>再指向了对象。<br><img src="https://upload-images.jianshu.io/upload_images/7762675-e6a4ef43167b73ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>如果对象的共有属性没有被引用的话，必将会被回收，<code>object.prototype</code>指向（引用）这个共有属性（原型）<br><img src="https://upload-images.jianshu.io/upload_images/7762675-18b79050063fef54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>当你声明一个对象时，JS引擎除了在栈内存里面存放一个hash之外，还将<code>____proto____</code>指向了你该有的共有属性（原型）。</p><h5 id="不写代码就有prototype"><a href="#不写代码就有prototype" class="headerlink" title="不写代码就有prototype"></a>不写代码就有prototype</h5><p>在没有代码的时候，<code>Number.prototype、Object.prototype、String.prototype、Boolean.prototype</code>都引用了各自的共有属性（保证不被垃圾回收机制回收），是JS定义的，不可更改的。而你的对象<code>____proto____</code>则指向了对应数据类型的<code>prototype</code>。<br><img src="https://upload-images.jianshu.io/upload_images/7762675-bcc66f9c3fee62a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>初始化数据类型里面还有一个<code>Function.prototype</code>，存储了函数的原型（共有方法），<code>Function</code>也是一个对象，<code>Function.__proto__</code>指向了<code>Function.prototype</code>，使用函数初始化对象时（<code>new Function()</code>)，该函数对象的<code>____proto____</code>就指向了<code>Function.prototype</code>（因为Function是Object的构造函数），而<code>Function.prototype</code>里面的<code>____proto____</code>就指向了<code>Object.prototype</code>。<br><img src="https://upload-images.jianshu.io/upload_images/7762675-b55a983b29328466.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>继承方式：子类构造函数.prototype= new 父类构造函数 ，简单说就是将父类的实例赋值给子类的原型。<br>目前组合继承用的最多，构造函数模式定义实例属性（不可共享），原型模式则定义方法和共享的属性。</p><p>现在你明白什么是原型和原型链了吗？：）</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;全局对象&quot;&gt;&lt;a href=&quot;#全局对象&quot; class=&quot;headerlink&quot; title=&quot;全局对象&quot;&gt;&lt;/a&gt;全局对象&lt;/h5&gt;&lt;p&gt;ECMAScript规定全区对象叫做global，但是浏览器把window作为全局对象（浏览器先存在的）window就是一个哈希表，有很多属性。window的属性就是全局变量。&lt;br&gt;window下面的属性分为两类，第一类是ECMAScript规定必须有的函数，第二类是私有的（浏览器专有，标准不一），MDN查看window下有哪些API。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="原型" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
      <category term="简单数据类型" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="复杂数据类型" scheme="http://yoursite.com/tags/%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="字符串API" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2API/"/>
    
  </entry>
  
  <entry>
    <title>JS数据类型转换</title>
    <link href="http://yoursite.com/2018/08/30/Js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2018/08/30/Js数据类型转换/</id>
    <published>2018-08-30T03:39:44.000Z</published>
    <updated>2018-09-02T01:19:10.663Z</updated>
    
    <content type="html"><![CDATA[<p>JS有5种简单数据类型（也称基本数据类型）：<code>undefined</code>、<code>null</code>、<code>Boolean</code>、<code>Number</code>和<code>String</code>。还有两种复杂数据类型——<code>symbol</code>（不做多介绍）和<code>Object</code>，对象本质上是由一组无序的名值对组成的，ECMAScring不支持任何创建自定义类型的机制，而所有值最终都将是上述7种数据类型之一。<br><a id="more"></a></p><h4 id="数据类型的相互转换"><a href="#数据类型的相互转换" class="headerlink" title="数据类型的相互转换"></a>数据类型的相互转换</h4><h5 id="任意数据类型转字符串"><a href="#任意数据类型转字符串" class="headerlink" title="任意数据类型转字符串"></a>任意数据类型转字符串</h5><p><code>String(x)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String(1)//&quot;1&quot;</span><br><span class="line"></span><br><span class="line">String(true)//&quot;true&quot;</span><br><span class="line"></span><br><span class="line">String(null)//&quot;null&quot;</span><br><span class="line"></span><br><span class="line">String(undefined)//&quot;undefined&quot;</span><br><span class="line"></span><br><span class="line">String(&#123;&#125;)//&quot;[Object Object]&quot;</span><br></pre></td></tr></table></figure></p><p><code>toString()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(1).toString()  //&quot;1&quot;</span><br><span class="line"></span><br><span class="line">true.toString() //&quot;true&quot;</span><br><span class="line"></span><br><span class="line">null.toString()  //Uncaught TypeError: Cannot read property &apos;toString&apos; of null</span><br><span class="line"> // at &lt;anonymous&gt;:1:6</span><br><span class="line"></span><br><span class="line">undefined.toString()  //Uncaught TypeError: Cannot read property &apos;toString&apos; of undefined</span><br><span class="line">//at &lt;anonymous&gt;:1:11</span><br><span class="line">&#123;&#125;.toString()   //Uncaught SyntaxError: Unexpected token .</span><br><span class="line"></span><br><span class="line">(&#123;&#125;).toString()  //&quot;[object Object]&quot;</span><br></pre></td></tr></table></figure></p><p><code>老司机用法：x+&#39;&#39;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1+&apos;&apos;  //  &quot;1&quot;</span><br><span class="line">true+&apos;&apos; // &apos;true&apos;</span><br><span class="line">null+&apos;&apos; // &apos;null&apos;</span><br><span class="line">undefined+&apos;&apos; // &apos;undefined&apos;</span><br><span class="line">&#123;&#125;+&apos;&apos; // 0</span><br><span class="line">var o = &#123;&#125;</span><br><span class="line">o+ &apos;&apos; //&#123;object Object&#125;</span><br></pre></td></tr></table></figure></p><hr><h5 id="任意数据类型转数字"><a href="#任意数据类型转数字" class="headerlink" title="任意数据类型转数字"></a>任意数据类型转数字</h5><ul><li><code>Number(x)</code></li><li><code>parselnt(x，10）</code><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">MDN</a></li><li><code>parseFloat(x)</code><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">MDN</a></li><li><code>x-0</code></li><li><code>+x</code></li></ul><hr><h5 id="任意数据类型转布尔值"><a href="#任意数据类型转布尔值" class="headerlink" title="任意数据类型转布尔值"></a>任意数据类型转布尔值</h5><ul><li><code>Boolean(x)</code></li><li><code>!!x</code><h5 id="五个falsy值"><a href="#五个falsy值" class="headerlink" title="五个falsy值"></a>五个falsy值</h5><code>0</code>      <code>NaN</code>     <code>&#39;&#39;</code>       <code>null</code>         <code>undefined</code>     <blockquote><p>falsy是在Boolean上下文中认定可转换为false的值。JavaScript在需要用到布尔类型的上下文中使用强制类型转换（Type  Conversion）将值转换为布尔值，比如：在条件语句或循环语句中</p></blockquote></li></ul><hr><h4 id="内存图"><a href="#内存图" class="headerlink" title="内存图"></a>内存图</h4><ul><li>你买一个 <a href="https://item.jd.com/4071422.html" title="null" target="_blank" rel="noopener">8G 的内存条</a></li><li>操作系统开机即占用 512MB</li><li>Chrome 打开即占用 1G 内存</li><li>Chrome 各每个网页分配一定数量的内存</li><li>这些内存要分给页面渲染器、网络模块、浏览器外壳和 JS 引擎（V8引擎）</li><li>JS 引擎将内存分为代码区和数据区</li><li>我们只研究数据区</li><li>数据区分为 Stack（栈内存） 和 Heap（堆内存）</li><li>简单类型的数据直接存在 Stack 里</li><li>复杂类型的数据是把 Heap 地址存在 Stack 里<br>遇到问题尽量画图分析。</li></ul><hr><p>如果将复杂数据类型存放在栈内存里面，那么向其中添加数据就很麻烦、其中一些数据就需要向后面移动。只需要在栈内存中给代表复杂数据类型（对象）的变量存放一个地址（没有指针，是引用）指向堆内存中的数据。一个变量等于另一个复杂数据类型，就把地址复制给它。<br>所有的变量和对象都是引用关系。</p><h5 id="4个常见的面试题"><a href="#4个常见的面试题" class="headerlink" title="4个常见的面试题"></a>4个常见的面试题</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">请问 a 显示是几？  <span class="comment">//1</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">name</span>: <span class="string">'a'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">b = &#123;<span class="attr">name</span>: <span class="string">'b'</span>&#125;</span><br><span class="line">请问现在 a.name 是多少？<span class="comment">//'a'</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">name</span>: <span class="string">'a'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">b.name = <span class="string">'b'</span></span><br><span class="line">请问现在 a.name 是多少？<span class="comment">//'b'</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">name</span>: <span class="string">'a'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">b = <span class="literal">null</span></span><br><span class="line">请问现在 a 是什么？<span class="comment">//&#123;name: 'a'&#125;</span></span><br></pre></td></tr></table></figure><h5 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h5><p><strong>GC 垃圾回收</strong> <code>如果一个对象没有被引用，那么它就是垃圾，将会被回收。</code><br>引用包括事件触发引用，如果一个函数被页面上的事件引用了，也不会算作垃圾被回收。<br>解决办法：将事件赋值null，就表示不再引用。<br><strong>IE6 BUG</strong>  无法正常的在页面关闭时，将没有人引用的垃圾正常的清除。设置window.onunload事件，将所有的事件都设置为null。<br><strong>内存泄露</strong>：表示该被标记为垃圾的数据没有被标记，内存就会被永久的占用。除非把整个浏览器关闭，否则浏览器就会吃很多的内存，无法再分配新的内存用于存储数据。</p><blockquote><p>程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果.</p></blockquote><h5 id="深复制是什么鬼"><a href="#深复制是什么鬼" class="headerlink" title="深复制是什么鬼"></a>深复制是什么鬼</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 1</span><br><span class="line">var b = a</span><br><span class="line">b = 2 //这个时候改变 b</span><br></pre></td></tr></table></figure><p>a 完全不受 b 的影响<br>那么我们就说这是一个深复制<br>对于简单类型的数据来说，赋值就是深拷贝。<br>对于复杂类型的数据（对象）来说，才要区分浅拷贝和深拷贝。</p><p>这是一个浅拷贝的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;name: &apos;frank&apos;&#125;</span><br><span class="line">var b = a</span><br><span class="line">b.name = &apos;b&apos;</span><br><span class="line">a.name === &apos;b&apos; // true</span><br></pre></td></tr></table></figure></p><p>因为我们对 b 操作后，a 也变了</p><p>什么是深拷贝了，就是对 Heap 内存进行完全的拷贝。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;name: &apos;frank&apos;&#125;</span><br><span class="line">var b = deepClone(a) // deepClone 还不知道怎么实现</span><br><span class="line">b.name = &apos;b&apos;</span><br><span class="line">a.name === &apos;a&apos; // true</span><br></pre></td></tr></table></figure></p><p>对于基本类型变量，简单的赋值就是深拷贝。改变一个变量，不影响赋值的变量，两者互不干扰。对于深浅拷贝，一般只讨论复杂数据类型。<br>复杂类型变量，a等于b，a改变导致b也会改变，这就是浅拷贝。因为只是将stack里面的地址复制了一份而已。复杂数据类型的深拷贝，会拷贝堆内存里面的数据，包括数据内的引用，将不再引用同一个地址，而是引用新拷贝的数据的地址。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS有5种简单数据类型（也称基本数据类型）：&lt;code&gt;undefined&lt;/code&gt;、&lt;code&gt;null&lt;/code&gt;、&lt;code&gt;Boolean&lt;/code&gt;、&lt;code&gt;Number&lt;/code&gt;和&lt;code&gt;String&lt;/code&gt;。还有两种复杂数据类型——&lt;code&gt;symbol&lt;/code&gt;（不做多介绍）和&lt;code&gt;Object&lt;/code&gt;，对象本质上是由一组无序的名值对组成的，ECMAScring不支持任何创建自定义类型的机制，而所有值最终都将是上述7种数据类型之一。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="数据类型转换" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="GC垃圾回收机制" scheme="http://yoursite.com/tags/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    
      <category term="深浅拷贝" scheme="http://yoursite.com/tags/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
</feed>
