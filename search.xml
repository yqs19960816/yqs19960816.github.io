<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS数据类型转换]]></title>
    <url>%2F2018%2F08%2F31%2FJs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[JS有5种简单数据类型（也称基本数据类型）：undefined、null、Boolean、Number和String。还有两种复杂数据类型——symbol（不做多介绍）和Object，对象本质上是由一组无序的名值对组成的，ECMAScring不支持任何创建自定义类型的机制，而所有值最终都将是上述7种数据类型之一。 数据类型的相互转换任意数据类型转字符串String(x)123456789String(1)//&quot;1&quot;String(true)//&quot;true&quot;String(null)//&quot;null&quot;String(undefined)//&quot;undefined&quot;String(&#123;&#125;)//&quot;[Object Object]&quot; toString()123456789101112(1).toString() //&quot;1&quot;true.toString() //&quot;true&quot;null.toString() //Uncaught TypeError: Cannot read property &apos;toString&apos; of null // at &lt;anonymous&gt;:1:6undefined.toString() //Uncaught TypeError: Cannot read property &apos;toString&apos; of undefined//at &lt;anonymous&gt;:1:11&#123;&#125;.toString() //Uncaught SyntaxError: Unexpected token .(&#123;&#125;).toString() //&quot;[object Object]&quot; 老司机用法：x+&#39;&#39;12345671+&apos;&apos; // &quot;1&quot;true+&apos;&apos; // &apos;true&apos;null+&apos;&apos; // &apos;null&apos;undefined+&apos;&apos; // &apos;undefined&apos;&#123;&#125;+&apos;&apos; // 0var o = &#123;&#125;o+ &apos;&apos; //&#123;object Object&#125; 任意数据类型转数字 Number(x) parselnt(x，10）MDN parseFloat(x)MDN x-0 +x 任意数据类型转布尔值 Boolean(x) !!x五个falsy值0 NaN &#39;&#39; null undefined falsy是在Boolean上下文中认定可转换为false的值。JavaScript在需要用到布尔类型的上下文中使用强制类型转换（Type Conversion）将值转换为布尔值，比如：在条件语句或循环语句中 内存图 你买一个 8G 的内存条 操作系统开机即占用 512MB Chrome 打开即占用 1G 内存 Chrome 各每个网页分配一定数量的内存 这些内存要分给页面渲染器、网络模块、浏览器外壳和 JS 引擎（V8引擎） JS 引擎将内存分为代码区和数据区 我们只研究数据区 数据区分为 Stack（栈内存） 和 Heap（堆内存） 简单类型的数据直接存在 Stack 里 复杂类型的数据是把 Heap 地址存在 Stack 里遇到问题尽量画图分析。 如果将复杂数据类型存放在栈内存里面，那么向其中添加数据就很麻烦、其中一些数据就需要向后面移动。只需要在栈内存中给代表复杂数据类型（对象）的变量存放一个地址（没有指针，是引用）指向堆内存中的数据。一个变量等于另一个复杂数据类型，就把地址复制给它。所有的变量和对象都是引用关系。 4个常见的面试题1234var a = 1var b = ab = 2请问 a 显示是几？ //1 1234var a = &#123;name: 'a'&#125;var b = ab = &#123;name: 'b'&#125;请问现在 a.name 是多少？//'a' 1234var a = &#123;name: 'a'&#125;var b = ab.name = 'b'请问现在 a.name 是多少？//'b' 1234var a = &#123;name: 'a'&#125;var b = ab = null请问现在 a 是什么？//&#123;name: 'a'&#125; 垃圾回收机制GC 垃圾回收 如果一个对象没有被引用，那么它就是垃圾，将会被回收。引用包括事件触发引用，如果一个函数被页面上的事件引用了，也不会算作垃圾被回收。解决办法：将事件赋值null，就表示不再引用。IE6 BUG 无法正常的在页面关闭时，将没有人引用的垃圾正常的清除。设置window.onunload事件，将所有的事件都设置为null。内存泄露：表示该被标记为垃圾的数据没有被标记，内存就会被永久的占用。除非把整个浏览器关闭，否则浏览器就会吃很多的内存，无法再分配新的内存用于存储数据。 程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果. 深复制是什么鬼123var a = 1var b = ab = 2 //这个时候改变 b a 完全不受 b 的影响那么我们就说这是一个深复制对于简单类型的数据来说，赋值就是深拷贝。对于复杂类型的数据（对象）来说，才要区分浅拷贝和深拷贝。 这是一个浅拷贝的例子1234var a = &#123;name: &apos;frank&apos;&#125;var b = ab.name = &apos;b&apos;a.name === &apos;b&apos; // true 因为我们对 b 操作后，a 也变了 什么是深拷贝了，就是对 Heap 内存进行完全的拷贝。1234var a = &#123;name: &apos;frank&apos;&#125;var b = deepClone(a) // deepClone 还不知道怎么实现b.name = &apos;b&apos;a.name === &apos;a&apos; // true 对于基本类型变量，简单的赋值就是深拷贝。改变一个变量，不影响赋值的变量，两者互不干扰。对于深浅拷贝，一般只讨论复杂数据类型。复杂类型变量，a等于b，a改变导致b也会改变，这就是浅拷贝。因为只是将stack里面的地址复制了一份而已。复杂数据类型的深拷贝，会拷贝堆内存里面的数据，包括数据内的引用，将不再引用同一个地址，而是引用新拷贝的数据的地址。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>数据类型转换</tag>
        <tag>垃圾回收机制</tag>
        <tag>深浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型和原型链]]></title>
    <url>%2F2018%2F08%2F30%2F%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[ECMAScript规定全区对象叫做global，但是浏览器把window作为全局对象（浏览器先存在的）window就是一个哈希表，有很多属性。window的属性就是全局变量。window下面的属性分为两类，第一类是ECMAScript规定必须有的函数，第二类是私有的（浏览器专有，标准不一），MDN查看window下有哪些API。今天我们学习第一种全局变量。windowde的函数可以直接调用，window.可省略。 简单类型与对象的区别：简单创建的数值和通过new Number创建的数值对象区别在于内存不同。将数值通过Number包装成对象，内存里面就有许多操作该数值的方法。但简单数据也可以调用这些办法，那为什么还需要将数值包装成对象呢？答：历史原因，在发明JS时模仿JAVA声明数据（new关键字，满足老板需求)，第二种可以直接声明var a =1。 由于第二种方法无法使用toString等方法（只有对象才能使用方法，简单数据类型不可以），创始人使用了一个妙计（临时转换）当写n.toString时，隐式的声明一个temp为 new Number(n)，然后再调用n.toString的值为temp，再销毁temp数据。临时的转换，用完就销毁了。所以给简单数据类型加属性读取时将会报错。 公有的属性藏在哪？所有的对象都有toString和valueOf属性，那么我们是否有必要给每个对象一个toString和valueOf呢？明显不需要（内存不允许），JS的做法是把toString和valueOf放在一个对象里，暂且叫做公有属性组成的对象（原型）。 对象分为普通对象和函数对象，Object和Function是js自带的函数对象，每个对象都有原型（null和undefined除外）可以理解为对象的默认属性和方法。 字符串对象通过new string()方法转换成的字符串对象是一个哈希，每一个字符对应相应的索引值，使用方括号或者charAt(索引值)来获取相对应的字符，charCodeAt（索引值）获取对应索引的值的编码。继承了String对象的方法。获取一个数字对应的进制值使用toString()方法，如（100）.toString(16) //64 可以将字符的编码转化为其他进制的编码 字符串常用API：去掉两边空格trim()连接字符串 concat() 得到新的字符串， 和命令行cat查看命令有关，两个文件 cat 1.txt 2.txt //将1和2的内容连接打印出来hello world切片slice，得到两个参数之间的字符（包前不包后）replace替换，将指定的字符切换为你想要的字符，得到新的字符串、基本类型也可以使用哈希表，只不过在调用的时候临时转换成了字符串对象而已 布尔值对象 简单数据类型false和布尔对象false在被转换时是不相等的。为什么不相等呢？请牢记5个假值，7个基本类型。对象是真值。两个对象地址值不同，自然不会相等。结论：所有新声明的对象都是不相等的。除非将一个对象的地址值赋值给另一个变量。 Number String Boolean Object通过以上几种方式创建的对象都具有toString、valueof方法，这两个方法哪里来的呢？在每个对象都定义这两个方法太占内存。解决方法：原型链、 原型链 什么是原型链：ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方式。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。在js中，每个对象都有一个指向它的原型对象的内部链接，这个原型对象又有自己的原型，直到某个对象的原型为null为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链接结构就称为原型链。JS对象有一个指向一个原型对象的链，当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象原型的原型，依此层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的，所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。这也正是所有自定义类型都会继承toString（），valueOf()等默认方法的根本原因，所有函数的原型最顶端都有一个最终的对象原型，存储着对象本身自带方法和属性，当调用实例上的toString()等方法时，实际上是调用的是保存在Object.prototype中的那个方法。 简单回顾一下构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。下面是一个简单的例子：两个构造函数，将其中一个构造函数的实例赋值给另一个构造函数的原型，这样另一个原型就有了指向前面那一个构造函数的原型的指针（创建的实例也会有同样的原型链），查找属性和方法会根据原型链来进行搜索，先搜索实例，再搜索原型，最后是原型的原型…..，注意此时实例的constructor指向了最开始的构造函数，而不是创建实例的函数（为了代码的严谨，可以设置为创建此实例的函数）。实现的本质是重写原型对象，代之以一个新类型的实例。原型链继承不仅会继承原型上面的属性和方法，还会继承实例上的方法和属性。 12345var o1 = new Number(1);var o2 =new Object(1);o1===o2 //falseo1.toString()===o2.toString() //true` 两个对象不相等，但使用的属性是公共属性(Number的原型)，因此相等。使用Object函数生成对象时，如果传入的值为简单数据类型，则会将其转化为对应的数据类型对象，而不是直接转化为对象。数值的toString()方法和对象的toString()方法并不相等，因为前者可以加参数而且会被先搜寻到。调用方法时，会经过一层一层的查找。Number String Boolean Object都有自己的共有属性，____proto____都是先指向了自己的共有属性，共有属性的__proto____再指向了对象。如果对象的共有属性没有被引用的话，必将会被回收，object.prototype指向（引用）这个共有属性（原型）当你声明一个对象时，JS引擎除了在栈内存里面存放一个hash之外，还将____proto____指向了你该有的共有属性（原型）。 不写代码就有prototype在没有代码的时候，Number.prototype、Object.prototype、String.prototype、Boolean.prototype都引用了各自的共有属性（保证不被垃圾回收机制回收），是JS定义的，不可更改的。而你的对象____proto____则指向了对应数据类型的prototype。 初始化数据类型里面还有一个Function.prototype，存储了函数的原型（共有方法），Function也是一个对象，Function.__proto__指向了Function.prototype，使用函数初始化对象时（new Function())，该函数对象的____proto____就指向了Function.prototype（因为Function是Object的构造函数），而Function.prototype里面的____proto____就指向了Object.prototype。 继承方式：子类构造函数.prototype= new 父类构造函数 ，简单说就是将父类的实例赋值给子类的原型。目前组合继承用的最多，构造函数模式定义实例属性（不可共享），原型模式则定义方法和共享的属性。 现在你明白什么是原型和原型链了吗？：）]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>原型</tag>
        <tag>原型链</tag>
        <tag>简单数据类型</tag>
        <tag>复杂数据类型</tag>
        <tag>字符串API</tag>
      </tags>
  </entry>
</search>
