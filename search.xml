<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS数据类型转换]]></title>
    <url>%2F2018%2F08%2F31%2FJs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[JS有5种简单数据类型（也称基本数据类型）：undefined、null、Boolean、Number和String。还有两种复杂数据类型——symbol（不做多介绍）和Object，对象本质上是由一组无序的名值对组成的，ECMAScring不支持任何创建自定义类型的机制，而所有值最终都将是上述7种数据类型之一。 数据类型的相互转换(强制转换)强制转换主要指使用Number、String和Boolean三个函数，手动将各种类型的值，分布转换成数字、字符串或者布尔值。 任意数据类型转字符串String(x)函数可以将任意类型的值转化成字符串，转换规则如下： String(1)//&quot;1&quot; 数值：转为相应的字符串 String(true)//&quot;true&quot; 布尔值：true转为字符串&quot;true&quot;，false转为字符串&quot;false&quot;。 String(null)//&quot;null&quot; 转为字符串&quot;null&quot;。 String(undefined)//&quot;undefined&quot; 转为字符串&quot;undefined&quot;。 String({})//&quot;[Object Object]&quot; 对象，返回一个类型字符串； String([1, 2, 3]) // &quot;1,2,3&quot; 数组，返回该数组的字符串形式。 toString()方法也可以将数据转化为字符串形式，不过undefined和null没有这个方法。 (1).toString() //&quot;1&quot; true.toString() //&quot;true&quot; null.toString() //Uncaught TypeError: Cannot read property &#39;toString&#39; of null // at &lt;anonymous&gt;:1:6 undefined.toString() //Uncaught TypeError: Cannot read property &#39;toString&#39; of undefined //at &lt;anonymous&gt;:1:11 {}.toString() //Uncaught SyntaxError: Unexpected token . ({}).toString() //&quot;[object Object]&quot; 老司机用法：x+&#39;&#39; 1+&#39;&#39; // &quot;1&quot; true+&#39;&#39; // &#39;true&#39; null+&#39;&#39; // &#39;null&#39; undefined+&#39;&#39; // &#39;undefined&#39; {}+&#39;&#39; // 0 var o = {} o+ &#39;&#39; //{object Object} 任意数据类型转数字 Number(x) parselnt(x，10）MDN parseFloat(x)MDN x-0 +x原始类型值的转换规则如下:`// 数值：转换后还是原来的值Number(324) // 324 // 字符串：如果可以被解析为数值，则转换为相应的数值Number(‘324’) // 324 // 字符串：如果不可以被解析为数值，返回 NaNNumber(‘324abc’) // NaN // 空字符串转为0Number(‘’) // 0 // 布尔值：true 转成 1，false 转成 0Number(true) // 1Number(false) // 0 // undefined：转成 NaNNumber(undefined) // NaN // null：转成0Number(null) // 0 `Number`函数将字符串转为数值，要比`parseInt`函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为`NaN`,parseInt逐个解析字符，而Number函数整体转换字符串的类型,另外，parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。 对象 简单的规则是，Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。 Number({a: 1}) // NaNNumber([1, 2, 3]) // NaNNumber([5]) // 5 *** ##### 任意数据类型转布尔值 * `Boolean(x)`函数可以将任意类型的值转为布尔值. * `!!x` 五个falsy值转换结果为false，其他的值全部为true。 `0` `NaN` `&#39;&#39;` `null` `undefined` &gt;falsy是在Boolean上下文中认定可转换为false的值。JavaScript在需要用到布尔类型的上下文中使用强制类型转换（Type Conversion）将值转换为布尔值，比如：在条件语句或循环语句中 注意，所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true。 *** #### 数据类型的相互转换(自动转换) 到以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见。 第一种情况，不同类型的数据互相运算。 123 + ‘abc’ // “123abc” 第二种情况，对非布尔值类型的数据求布尔值。 if (‘abc’) { console.log(‘hello’)} // “hello” 第三种情况，对非数值类型的值使用一元运算符（即+和-）。 {foo: ‘bar’} // NaN [1, 2, 3] // NaN`自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用String函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。 由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用Boolean、Number和String函数进行显式转换。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>数据类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型和原型链]]></title>
    <url>%2F2018%2F08%2F30%2F%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[ECMAScript规定全区对象叫做global，但是浏览器把window作为全局对象（浏览器先存在的）window就是一个哈希表，有很多属性。window的属性就是全局变量。window下面的属性分为两类，第一类是ECMAScript规定必须有的函数，第二类是私有的（浏览器专有，标准不一）。 简单类型与对象的区别：简单创建的数值和通过new Number创建的数值对象区别在于内存不同,前者存放在stack中，而后者存放在heap。将数值通过Number包装成对象，内存里面就有许多操作该数值的方法。但简单数据也可以调用这些办法，那为什么还需要将数值包装成对象呢？答：历史原因，在发明JS时模仿JAVA声明数据（new关键字，满足老板需求)，第二种可以直接声明var a =1。 由于第二种方法无法使用toString等方法（只有对象才能使用方法，简单数据类型不可以），创始人使用了一个妙计（临时转换）当写n.toString时，隐式的声明一个temp为 new Number(n)，然后再调用n.toString的值为temp，再销毁temp数据。临时的转换，用完就销毁了。所以给简单数据类型加属性读取时将会报错，这种方法受到了开发人员的欢迎。 公有的属性藏在哪？所有的对象都有toString和valueOf属性，那么我们是否有必要给每个对象一个toString和valueOf呢？明显不需要（内存不允许），JS的做法是把toString和valueOf放在一个对象里，暂且叫做公有属性组成的对象（原型）。 对象分为普通对象和函数对象，Object和Function是js自带的函数对象，每个对象都有原型（null和undefined除外）可以理解为对象的默认属性和方法。 字符串对象通过new string()方法转换成的字符串对象是一个哈希，每一个字符对应相应的索引值，使用方括号或者charAt(索引值)来获取相对应的字符，charCodeAt（索引值）获取对应索引的值的编码。继承了String对象的方法。获取一个数字对应的进制值使用toString()方法，如（100）.toString(16) //64 可以将字符的编码转化为其他进制的编码 布尔值对象 简单数据类型false和布尔对象false在被转换时是不相等的。为什么不相等？两个对象地址值不同，自然不会相等,请牢记5个假值，对象经过布尔转换为真值。结论：所有新声明的对象都是不相等的。除非将一个对象的地址值赋值给另一个变量。 Number String Boolean Object通过以上几种方式创建的对象都具有toString、valueof方法，这两个方法哪里来的呢？如果在每个对象都定义这两个方法太占内存。实现继承的方法：原型链、 要清楚原型链，首先先弄清楚对象。普通对象,有proto属性(指向其原型链)，没有prototype属性。 原型对象,构造函数.prototype原型对象还有constructor属性指向构造函数对象*函数对象，通过new Function()创建的都是函数对象。用有prototype、proto属性(指向原型对象) 原型链概念ECMAScript中描述了原型链的机制，将原型链作为实现继承的主要方式。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。在js中，每个对象都有一个指向它的原型对象的内部链接，这个原型对象又有自己的原型，直到某个对象的原型为null为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链接结构就称为原型链。JS对象有一个指向一个原型对象的链，当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象原型的原型，依此层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。 所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的，所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。这也正是所有自定义类型都会继承toString（），valueOf()等默认方法的根本原因，所有函数的原型最顶端都有一个最终的对象原型，存储着对象本身自带方法和属性，当调用实例上的toString()等方法时，实际上是调用的是保存在Object.prototype中的那个方法。 简单回顾一下构造函数、原型和实例之间的关系：每创建一个函数都有一个prototype属性指向通过该构造函数创建实例对象的原型对象，原型对象是包含特定类型的所有实例共享的属性和方法，都包含了一个指向构造函数的指针，而实例都包含一个指向原型对象的proto内部指针。下面是一个简单的例子：两个构造函数，将其中一个构造函数的实例赋值给另一个构造函数的原型，这样另一个原型就有了指向前面那一个构造函数的原型的指针（创建的实例也会有同样的原型链），查找属性和方法会根据原型链来进行搜索，先搜索实例，再搜索原型，最后是原型的原型…..，注意此时实例的constructor指向了最开始的构造函数，而不是创建实例的函数（为了代码的严谨，可以设置为创建此实例的函数）。实现的本质是重写原型对象，代之以一个新类型的实例。原型链继承不仅会继承原型上面的属性和方法，还会继承实例上的方法和属性。 var o1 = new Number(1); var o2 =new Object(1); o1===o2 //false o1.toString()===o2.toString() //true ` 两个数值对象不相等,因为stack存放的heap地址值不同，但使用的函数是公共属性(Number的原型的属性)，因此相等。Object()函数不加new操作符会根据传入的参数生成相应的数据类型的对象，对于Object函数来说，加不加new都是一样的效果。String()函数不加new操作符是将你给定的参数变成string常量（基本类型，非对象），而加上new会生成String对象（复杂类型，字符串对象），除了Object函数以外，其他的标准库函数都是一样的效果。数值的toString()方法和对象的toString()方法并不相等，因为前者可以加进制参数而且会被先搜寻到。调用方法时，会经过一层一层的查找。Number String Boolean Object都有自己的共有属性，____proto____都是先指向了自己的共有属性，共有属性的__proto____再指向了对象。如果对象的共有属性没有被引用的话，必将会被回收，object.prototype指向（引用）这个共有属性（原型）当你声明一个对象时，JS引擎除了在栈内存里面存放一个hash之外，还将____proto____指向了你该有的共有属性（原型）。 不写代码就有prototype在没有代码的时候，Number.prototype、Object.prototype、String.prototype、Boolean.prototype都引用了各自的共有属性（保证不被垃圾回收机制回收），是JS定义的，不可更改的。而你的对象____proto____则指向了对应数据类型的prototype。 初始化数据类型里面还有一个Function.prototype，存储了函数的原型（共有方法），Function也是一个对象，Function.__proto__指向了Function.prototype，使用函数初始化对象时（new Function())，该函数对象的____proto____就指向了Function.prototype（因为Function是Object的构造函数），而Function.prototype里面的____proto____就指向了Object.prototype。 继承方式：子类构造函数.prototype= new 父类构造函数 ，简单说就是将父类的实例赋值给子类的原型，这样子类的proto属性目前组合继承用的最多，构造函数模式定义实例属性（不可共享），原型模式则定义方法和共享的属性。 现在你明白什么是原型和原型链了吗？：）]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>原型</tag>
        <tag>原型链</tag>
        <tag>简单数据类型</tag>
        <tag>复杂数据类型</tag>
      </tags>
  </entry>
</search>
